# 实验二 事务层——TinyKV 部分

## 设计思路

在实验一中，我们完成了 Raft 日志引擎和存储引擎的开发。借助 Raft 日志引擎，事务日志能够实现“可靠”持久化，且在故障转移后仍可恢复原有状态。本章将介绍**分布式事务层**的设计与实现方案。Raft 日志引擎已经保障了数据的持久性和状态恢复能力，而事务层则需要进一步保证事务的原子性，以及在并发场景下的正确性，也就是隔离性。

本实验采用 **Percolator 协议**来保障事务原子性，并通过**全局时间戳排序**机制对并发事务的执行顺序进行管控。基于这两者，可为客户端提供一种强隔离级别，该级别通常被称为**快照隔离**或**可重复读**。
Percolator 协议同时在 TinySQL 和 TinyKV 服务器中实现，全局事务时间戳的分配则由 TinyScheduler 服务器负责，且所有逻辑时间戳均保持单调递增。本实验需要完成 TinyKV 侧的 Percolator 协议实现，即分布式事务参与者的相关功能。

## 在 TinyKV 中实现 Percolator 协议

事务的处理流程如下所示：
![事务总览](imgs/transaction_overview.PNG)

用户向 TinySQL 服务器发送写入类查询请求（例如 `Insert` 语句），服务器对请求进行解析和执行后，会将用户数据从行格式转换为键值对格式。
随后，事务模块负责将这些键值对提交至存储引擎。由于不同的键可能分布在不同的 Region 中，而这些 Region 又可能部署在不同的 TinyKV 服务器上，因此事务引擎必须确保提交过程最终**要么完全成功**，**要么完全不生效**，这正是 Percolator 协议需要解决的核心问题。

接下来以一个包含多个键的分布式事务提交过程为例进行说明。首先，会从待提交的所有键中选择一个作为**主键（Primary Key）**，该事务的最终状态完全由这个主键的提交状态决定。换句话说，只有当主键提交成功时，整个事务才会被判定为提交成功。
事务的提交过程分为两个阶段：第一阶段是**预写（Prewrite）**，第二阶段是**提交（Commit）**。

### 预写阶段

完成键值对的准备工作后，事务便进入预写阶段。在这个阶段，所有待提交的键会被分别写入对应 Region Leader 所在的 TinyKV 服务器。
每一个预写请求都会由对应的 TinyKV 服务器处理，并为每个键在存储引擎的**锁列族（lock column family）** 中写入一条预写锁记录。如果任意一个键的预写操作失败，整个提交流程会立即终止，同时清理所有已写入的预写锁。

### 提交阶段

若所有键的预写操作均执行成功，事务将进入提交阶段。在此阶段，系统会**优先提交主键**。提交操作具体包括两步：一是在存储引擎的**写列族（write column family）** 中写入一条写记录，二是在锁列族中释放该主键对应的预写锁。
一旦主键提交成功，整个事务即被判定为提交完成，并向客户端返回成功响应。其余的键（称为**次键/从键，Secondary Keys**）则会在后台任务中被**异步提交**。

在正常的执行流程中，以上两个阶段就足以完成事务提交，但这并未考虑**故障恢复**的场景。在分布式环境中，故障可能发生在任意节点，例如 TinySQL 服务器可能在两阶段提交未完成时崩溃，TinyKV 服务器也可能出现类似故障。当新的 Region Leader 被选举出来并开始处理请求时，我们该如何**恢复未完成的事务并保证数据正确性**？

### 回滚记录

一旦事务被判定为提交失败，需要清理其遗留的所有锁，并在存储引擎中写入一条回滚记录。这样做是为了防止因网络延迟等问题，后续出现针对该事务的预写或提交操作。
因此，只要在某个事务的主键上写入了回滚记录，该事务的状态就被确定为**已回滚**，此后永远无法提交，且必然执行失败。

### 事务状态校验

正如前文所述，一个事务的最终状态仅由其**主键或主键锁**的状态决定。因此，当某个事务的状态无法确定时，需要去校验其主键或主键锁的状态：

1. 若主键存在对应的提交记录或回滚记录，则可以明确判定该事务已提交或已回滚；
2. 若主键锁仍然存在且未过期，则说明该事务的提交流程可能仍在进行中；
3. 若主键既无锁记录，也无提交/回滚记录，则事务状态处于未知状态，此时可以选择等待，或直接写入回滚记录以阻止后续提交，进而将事务判定为回滚状态。

两阶段提交过程中生成的每一条预写锁，都会包含一个**生存时间（Time To Live, TTL）** 字段。当锁的生存时间过期后，像 `CheckTxnStatus` 这类并发命令可以将其回滚，且该事务最终必定执行失败。

### 冲突处理与故障恢复

不同的事务协调器可能部署在不同的 TinySQL 服务器上，读写请求之间可能会产生冲突。举个例子：事务 `txn1` 已经在键 `k1` 上写入了预写锁，此时另一个读事务 `txn2` 尝试读取键 `k1`，`txn2` 应该如何处理？

由于锁记录的存在，读写请求无法继续执行，此时存在以下几种可能性：

1. 该锁所属的事务已经提交成功，此时可以将该锁一并提交，之后被阻塞的请求就能继续操作该键；
2. 该锁所属的事务已经回滚，此时可以将该锁一并回滚，之后被阻塞的请求就能继续操作该键；
3. 该锁所属的事务仍在执行中，被阻塞的请求需要等待阻塞它的事务执行完成。

在 TinySQL/TinyKV 集群中，这类冲突处理逻辑被称为**锁解析（Resolve）**。当某个请求被其他事务的预写锁阻塞时，会触发锁解析流程，以此确定该锁的最终状态，并对锁执行提交或回滚操作，从而让被阻塞的请求得以继续执行。
锁解析操作还能**隐式地完成事务恢复**工作。比如这样一种场景：事务协调器完成所有预写锁的写入后，TinySQL 服务器突然崩溃，此时遗留的锁会由其他 TinySQL 服务器发送的并发事务请求触发解析流程来处理。

## 实验二任务

本实验需要在 TinyKV 服务器中实现上述接口及其对应的处理逻辑。

### 代码结构

#### 命令抽象（`Command` Abstraction）

在文件 `kv/transaction/commands/command.go` 中，定义了所有事务命令的统一接口：

```go
// Command 是一个抽象接口，涵盖了从接收 gRPC 请求到返回响应的完整处理流程
type Command interface {
    // 返回命令的上下文信息
    Context() *kvrpcpb.Context
    // 返回事务的启动时间戳
    StartTs() uint64
    // WillWrite 返回当前命令可能会写入的所有键的列表
    // 如果是只读命令，返回 nil
    WillWrite() [][]byte
    // Read 执行命令的只读逻辑
    // 仅在 WillWrite 返回 nil 时被调用
    // 如果命令需要向数据库写入数据，则应返回一组非空的待写入键列表
    Read(txn *mvcc.RoTxn) (interface{}, [][]byte, error)
    // PrepareWrites 用于在 MVCC 事务中构建待写入的数据
    // 命令也可以通过 txn 执行非事务性的读写操作
    // 如果方法执行后未对 txn 进行任何修改，则表示不会执行任何事务操作
    PrepareWrites(txn *mvcc.MvccTxn) (interface{}, error)
}
```

`WillWrite` 方法用于生成当前请求需要写入的内容；`Read` 方法负责执行命令所需的只读逻辑；`PrepareWrites` 方法用于构建命令实际要写入的数据，是处理写命令的核心逻辑。
每个事务都有唯一的标识，即由全局时间戳分配器生成的 `start_ts`（启动时间戳），`StartTs` 方法的作用就是返回当前命令所属事务的启动时间戳。

请尝试理解客户端请求的完整处理流程：事务命令的执行会生成一系列写入操作，这些写入操作会被转换成 Raft 命令请求并发送至 RaftStore；经过 RaftStore 的提案、提交和应用等处理步骤后，事务命令才算执行成功，最终将执行结果返回给客户端。
![Raft 存储引擎](imgs/raftstore.png)

#### 实现 `Get` 命令

`KvGet` 命令用于执行点查询操作，获取指定键对应的值。请补全文件 `kv/transaction/commands/get.go` 中缺失的代码，缺失部分均标注有：

```go
// YOUR CODE HERE (lab2).
```

#### 实现 `Prewrite` 和 `Commit` 命令

这两个接口是事务引擎中最重要的核心接口。请补全文件 `kv/transaction/commands/prewrite.go` 和 `kv/transaction/commands/commit.go` 中缺失的代码，缺失部分均标注有：

```go
// YOUR CODE HERE (lab2).
```

**注意事项**：

1. 由于这些命令是通过 RPC 请求从 TinySQL 服务器发送的，可能会出现重复请求的情况；
2. `StartTS` 是唯一标识一个事务的标识符；
3. `CommitTS` 是某条记录预期的提交时间戳；
4. 需考虑读写冲突的处理逻辑。

完成上述两部分代码后，执行 `make lab2P1` 命令，检查所有测试用例是否通过。

#### 实现 `Rollback` 和 `CheckTxnStatus` 命令

`Rollback` 命令用于释放指定键的锁，并为该键写入一条回滚记录；`CheckTxnStatus` 命令用于查询指定事务的主键锁状态。
请补全文件 `kv/transaction/commands/rollback.go` 和 `kv/transaction/commands/checkTxn.go` 中缺失的代码，缺失部分均标注有：

```go
// YOUR CODE HERE (lab2).
```

完成上述代码后，执行 `make lab2P2` 命令，检查所有测试用例是否通过。

**注意事项**：

1. 需考虑待查询的锁不存在的场景；
2. 由于这些命令是通过 RPC 请求从 TinySQL 服务器发送的，可能会出现重复请求的情况；
3. `CheckTxnStatusResponse` 中包含三种不同的响应动作：
   - `Action_TTLExpireRollback`：表示目标锁因生存时间过期而被回滚；
   - `Action_LockNotExistRollback`：表示目标锁不存在，且已为其写入回滚记录。

#### 实现 `ResolveLock` 命令

当某个事务的状态已经确定时，`Resolve` 命令用于对该事务遗留的锁执行提交或回滚操作。请补全文件 `kv/transaction/commands/resolve.go` 中缺失的代码，缺失部分均标注有：

```go
// YOUR CODE HERE (lab2).
```

完成上述代码后，执行 `make lab2P3` 命令，检查所有测试用例是否通过。

**注意事项**：

1. 事务的最终状态已在输入请求参数中明确指定；
2. `rollbackKey` 和 `commitKey` 这两个工具函数可能会对实现有所帮助。

完成所有命令的开发和测试后，执行 `make lab2P4` 命令，验证另一套测试用例是否通过。
在下一个实验中，我们将在 TinySQL 服务器中实现 Percolator 协议的事务协调器部分，届时会用到本章实现的所有命令接口。
